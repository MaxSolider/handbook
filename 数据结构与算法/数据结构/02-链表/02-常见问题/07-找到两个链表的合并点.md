# æ‰¾åˆ°ä¸¤ä¸ªé“¾è¡¨çš„åˆå¹¶ç‚¹

> [!Tip]
> 
> æœ¬èŠ‚æºä»£ç è§[Githubé“¾æ¥ğŸ”—](https://github.com/MaxSolider/leetcode-algorithm/blob/main/structure/src/main/java/org/example/linkedlist/exercises/FindIntersectingNode.java)

---
## é—®é¢˜æè¿°
å‡è®¾ä¸¤ä¸ªå•å‘é“¾è¡¨åœ¨æŸä¸ªç»“ç‚¹ç›¸äº¤åï¼Œæˆä¸ºä¸€ä¸ªå•å‘é“¾è¡¨ã€‚ä¸¤ä¸ªé“¾è¡¨çš„è¡¨å¤´ç»“ç‚¹æ˜¯å·²çŸ¥çš„ï¼Œä½†æ˜¯ç›¸äº¤çš„ç»“ç‚¹æœªçŸ¥ã€‚è®¾è®¡ç®—æ³•æ‰¾åˆ°ä¸¤ä¸ªé“¾è¡¨çš„åˆå¹¶ç‚¹
![æ‰¾åˆ°ä¸¤ä¸ªå•å‘é“¾è¡¨çš„åˆå¹¶ç‚¹.png](https://s2.loli.net/2022/10/09/ryLXvINE8iYxVqw.png)

---
## æ ¸å¿ƒæ€è·¯
é€šè¿‡åŒæŒ‡é’ˆè§£å†³ã€‚å…ˆå°†ä¸¤ä¸ªæŒ‡é’ˆç§»åŠ¨åˆ°è·ç¦»åˆå¹¶ç‚¹ç›¸åŒè·ç¦»çš„ä½ç½®ï¼ˆå¦‚ä¸Šå›¾åˆ†åˆ«æ˜¯*1*å’Œ*3*ï¼‰ï¼Œç„¶ååŒæ—¶ç§»åŠ¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸¤ä¸ªæŒ‡é’ˆç›¸é‡ç‚¹å³åˆå¹¶ç‚¹ã€‚ä¸»è¦åŒ…å«ä»¥ä¸‹3æ­¥ï¼š
1. åˆ†åˆ«è®¡ç®—ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ï¼›
2. ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦å·®å€¼ï¼Œå³é•¿é“¾è¡¨æŒ‡é’ˆéœ€è¦å‘å‰ç§»åŠ¨çš„è·ç¦»ï¼Œå¦‚ä¸Šå›¾ä¸­é•¿é“¾è¡¨æŒ‡é’ˆéœ€è¦å‘å‰ç§»åŠ¨1ä¸ªç»“ç‚¹ï¼›
3. æŒ‰ç›¸åŒé€Ÿåº¦åŒæ—¶ç§»åŠ¨ä¸¤ä¸ªæŒ‡é’ˆï¼ŒæŒ‡é’ˆç›¸é‡ç‚¹å³åˆå¹¶ç‚¹ã€‚

---
## å®ç°ä»£ç 
<details> 
	<summary>ã€ğŸ‘‰ğŸ»>>ç‚¹å‡»å±•å¼€æŸ¥çœ‹ä»£ç ã€‘</summary> 
	<pre>
		<code>
			/**  
			 * æ‰¾åˆ°ä¸¤ä¸ªå•å‘é“¾è¡¨çš„åˆå¹¶ç‚¹  
			 *  
			 * @param firstHeadNode  ç¬¬ä¸€ä¸ªé“¾è¡¨çš„è¡¨å¤´æŒ‡é’ˆ  
			 * @param secondHeadNode ç¬¬äºŒä¸ªé“¾è¡¨çš„è¡¨å¤´æŒ‡é’ˆ  
			 * @return NormalListNode  
			 * @author: Max Solider  
			 * @date: 2022/10/9 14:18  
			 */
			 NormalListNode findIntersectingNode(NormalListNode firstHeadNode, NormalListNode secondHeadNode) {  
			    if (firstHeadNode == null || secondHeadNode == null) {  
			        return null;  
			    }  
			    // è®¡ç®—ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦  
			    int firstLength = getListLength(firstHeadNode);  
			    int secondLength = getListLength(secondHeadNode);  
			    // è®¡ç®—ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦å·®å€¼  
			    NormalListNode longerNode = null;  
			    NormalListNode shorterNode = null;  
			    int diffLength = 0;  
			    if (firstLength > secondLength) {  
			        longerNode = firstHeadNode;  
			        shorterNode = secondHeadNode;  
			        diffLength = firstLength - secondLength;  
			    } else {  
			        longerNode = secondHeadNode;  
			        shorterNode = firstHeadNode;  
			        diffLength = secondLength - firstLength;  
			    }  
			    // å°†æŒ‡å‘æ›´é•¿é“¾è¡¨çš„æŒ‡é’ˆå‘å‰ç§»åŠ¨ï¼Œç›´åˆ°ä¸¤ä¸ªæŒ‡é’ˆè·ç¦»åˆå¹¶ç‚¹çš„è·ç¦»ç›¸åŒ  
			    while (diffLength > 0) {  
			        longerNode = longerNode.getNext();  
			        diffLength--;  
			    }  
			    // ä¸¤ä¸ªæŒ‡é’ˆåŒæ—¶ç§»åŠ¨ï¼Œç›¸é‡ç‚¹å³åˆå¹¶ç‚¹ã€‚è‹¥æ²¡ç›¸é‡åˆ™è¯´æ˜æ²¡æœ‰åˆå¹¶  
			    while (longerNode != null) {  
			        if (longerNode == shorterNode) {  
			            System.out.println("The merging point of two linked lists is " + longerNode.getData());  
			            return longerNode;  
			        }  
			        longerNode = longerNode.getNext();  
			        shorterNode = shorterNode.getNext();  
			    }  
			    System.out.println("The is no merging point of two linked lists.");  
			    return null;
			}  
			  
			/**  
			 * è®¡ç®—é“¾è¡¨é•¿åº¦  
			 *  
			 * @param headNode é“¾è¡¨å¤´æŒ‡é’ˆ  
			 * @return int é“¾è¡¨é•¿åº¦  
			 * @author: Max Solider  
			 * @date: 2022/10/9 16:36  
			 */static int getListLength(NormalListNode headNode) {  
			    if (headNode == null) {  
			        return 0;  
			    }  
			    int count = 0;  
			    NormalListNode node = headNode;  
			    while (node != null) {  
			        node = node.getNext();  
			        count++;  
			    }  
			    return count;  
			}
		</code>
	</pre>
</details>

---
## æ—¶é—´å¤æ‚åº¦
æ—¶é—´å¤æ‚åº¦ä¸º*O(max(n,m))*ï¼Œç”¨äºéå†é“¾è¡¨ã€‚

---
## ç©ºé—´å¤æ‚åº¦
ç©ºé—´å¤æ‚åº¦ä¸º*O(1)*ï¼Œç”¨äºå­˜å‚¨ä¸´æ—¶å˜é‡ã€‚
